*** src/pl/plpgsqlo/src/Makefile	2010-04-12 12:24:05.000000000 +0530
--- src/pl/plpgsqlo_final_working/src/Makefile	2010-04-07 17:30:34.000000000 +0530
***************
*** 8,26 ****
  
  subdir = src/pl/plpgsqlo/src
  top_builddir = ../../../..
  include $(top_builddir)/src/Makefile.global
  
  # Shared library parameters
  NAME= plpgsqlo
  
! override CPPFLAGS := -I. -I$(srcdir) $(CPPFLAGS)
! SHLIB_LINK = $(filter -lintl, $(LIBS))
! rpath =
  
! OBJS = pl_gram.o pl_handler.o pl_comp.o pl_exec.o pl_funcs.o pl_scanner.o
  
  all: all-lib
  
  # Shared library stuff
  include $(top_srcdir)/src/Makefile.shlib
  
--- 8,46 ----
  
  subdir = src/pl/plpgsqlo/src
  top_builddir = ../../../..
+ 
  include $(top_builddir)/src/Makefile.global
  
  # Shared library parameters
  NAME= plpgsqlo
  
! LINKED_SOURCES= wrap.c md5.c encode.c
! 
! OBJS = pl_gram.o pl_handler.o pl_comp.o pl_exec.o pl_funcs.o pl_scanner.o encode.o wrap.o md5.o
  
! PLPGSQLO_OBJS=   wrap.o md5.o encode.o
  
  all: all-lib
  
+ # XXX: We should make sure that "wrap.c" is compiled with all
+ # optimizations and without -g, to make reverse engineering a bit harder.
+ #override CPPFLAGS := -I. -I$(srcdir) $(CPPFLAGS)
+ override CPPFLAGS := -I. -I$(pgcrypto_dir) -I$(srcdir) $(CPPFLAGS)
+ 
+ 
+ SHLIB_LINK = $(filter -lintl, $(LIBS)) -lz
+ rpath =
+ 
+ 
+ # This location might depend on the installation directories. Therefore
+ # we can't subsitute it into pg_config.h.
+ ifdef krb_srvtab
+ override CPPFLAGS += -DPG_KRB_SRVTAB='"$(krb_srvtab)"'
+ endif
+ 
+ include $(top_srcdir)/src/backend/common.mk
+ 
+ 
  # Shared library stuff
  include $(top_srcdir)/src/Makefile.shlib
  
*** src/tools/msvc/Mkvcbuild.pm	Wed Apr 14 15:23:02 2010
--- src/tools/msvc/Mkvcbuild.pm_modified	Wed Apr 14 19:02:17 2010
***************
*** 85,90 ****
--- 85,99 ----
      $plpgsql->AddFiles('src\pl\plpgsql\src', 'gram.y');
      $plpgsql->AddReference($postgres);
  
+     my $plpgsqlo =  $solution->AddProject('plpgsqlo','dll','PLs','src\pl\plpgsqlo\src');
+     $plpgsqlo->AddFiles('src\pl\plpgsqlo\src', 'gram.y');
+     $plpgsqlo->AddFiles('src\pl\plpgsqlo\src', 'encode.c');
+     $plpgsqlo->AddFiles('src\pl\plpgsqlo\src', 'wrap.c');
+     $plpgsqlo->AddFiles('src\pl\plpgsqlo\src', 'md5.c');
+     $plpgsqlo->AddReference($postgres);
+     $plpgsqlo->AddLibrary('ws2_32.lib');
+ 
+ 
      if ($solution->{options}->{perl})
      {
  		my $plperlsrc = "src\\pl\\plperl\\";
*** src/tools/msvc/Project.pm	Wed Apr 14 12:27:06 2010
--- src/tools/msvc/Project.pm_modified	Wed Apr 14 12:26:54 2010
***************
*** 395,400 ****
--- 395,401 ----
              my $of = $f;
              $of =~ s/\.y$/.c/;
              $of =~ s{^src\\pl\\plpgsql\\src\\gram.c$}{src\\pl\\plpgsql\\src\\pl_gram.c};
+             $of =~ s{^src\\pl\\plpgsqlo\\src\\gram.c$}{src\\pl\\plpgsqlo\\src\\pl_gram.c};
              print F '>'
                . $self->GenerateCustomTool('Running bison on ' . $f,
                  'cmd /V:ON /c src\tools\msvc\pgbison.bat ' . $f, $of)
*** src/pl/plpgsqlo/src/encode.c	2010-04-13 17:07:43.000000000 +0530
--- src/pl/plpgsqlo/src/encode_working.c	2010-04-13 17:07:06.000000000 +0530
***************
*** 3,22 ****
   * encode.c
   *	  Various data encoding/decoding things.
   *
!  * Copyright (c) 2001-2010, PostgreSQL Global Development Group
   *
   *
   * IDENTIFICATION
!  *	  $PostgreSQL: pgsql/src/backend/utils/adt/encode.c,v 1.26 2010/01/02 16:57:53 momjian Exp $
   *
   *-------------------------------------------------------------------------
   */
  #include "postgres.h"
! 
  #include <ctype.h>
  
  #include "utils/builtins.h"
  
  
  struct pg_encoding
  {
--- 3,43 ----
   * encode.c
   *	  Various data encoding/decoding things.
   *
!  * Copyright (c) 2001-2009, PostgreSQL Global Development Group
   *
   *
   * IDENTIFICATION
!  *	  $PostgreSQL$
   *
   *-------------------------------------------------------------------------
   */
  #include "postgres.h"
! #include "wrap.h"
  #include <ctype.h>
  
  #include "utils/builtins.h"
  
+ #ifdef FRONTEND
+ 
+ #include "postgres_fe.h"
+ #undef ereport
+ #define ereport(x,y) (fprintf(stderr, "edbwrap error: could not wrap\n"), exit(1))
+ #undef elog
+ #define elog(x,y) (fprintf(stderr, "edbwrap error: could not wrap\n"), exit(1))
+ 
+ /* No assert checks in frontend ... */
+ #undef Assert
+ #define Assert(condition)
+ 
+ /* Frontend-specific memory handling  */
+ #undef palloc
+ #define palloc fe_palloc
+ #undef pfree
+ #define pfree free
+ 
+ extern void * fe_palloc(int size);
+ 
+ #endif /* ifdef FRONTEND */
  
  struct pg_encoding
  {
***************
*** 26,34 ****
--- 47,110 ----
  	unsigned	(*decode) (const char *data, unsigned dlen, char *res);
  };
  
+ #ifndef FRONTEND
  static const struct pg_encoding *pg_find_encoding(const char *name);
+ #endif
+ 
+ static unsigned b64_encode(const char *src, unsigned len, char *dst);
+ static unsigned b64_enc_len(const char *src, unsigned srclen);
+ static unsigned b64_decode(const char *src, unsigned len, char *dst);
+ static unsigned b64_dec_len(const char *src, unsigned srclen);
+ 
+ /*
+  * Base64 encode 'data', of length 'datalen'. Returns a palloc'd,
+  * null-terminated string.
+  */
+ char *
+ encode_base64(char *data, int datalen)
+ {
+ 	char *result;
+ 	int   res;
+ 	int   estlen;
+ 
+ 	estlen     = b64_enc_len(data, datalen);
+ 	result     = palloc(estlen + 1);
+ 	res        = b64_encode(data, datalen, result);
+ 	
+ 	/* Make this FATAL 'cause we've trodden on memory ... */
+ 	if (res > estlen)
+ 		elog(FATAL, "overflow - encode estimate too small");
+ 
+ 	result[res] = '\0';
+ 
+ 	return result;
+ }
  
  /*
+  * Decodes a base64 encoded, null-terminated string 'data'. The returned
+  * piece of memory is palloc'd, and its length is stored in *resultlen.
+  */
+ char *
+ decode_base64(char *data, int *resultlen)
+ {
+ 	char *result;
+ 	int   estlen;
+ 	int   datalen = strlen(data);
+ 
+ 	estlen     = b64_dec_len(data, datalen);
+ 	result 	   = palloc(estlen);
+ 	*resultlen = b64_decode(data, datalen, result);
+ 	
+ 	/* Make this FATAL 'cause we've trodden on memory ... */
+ 	if (*resultlen > estlen)
+ 		elog(FATAL, "overflow - encode estimate too small");
+ 
+ 	return result;
+ }
+ 
+ 
+ #ifndef FRONTEND
+ /*
   * SQL functions.
   */
  
***************
*** 109,115 ****
   * HEX
   */
  
! static const char hextbl[] = "0123456789abcdef";
  
  static const int8 hexlookup[128] = {
  	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
--- 185,191 ----
   * HEX
   */
  
! static const char *hextbl = "0123456789abcdef";
  
  static const int8 hexlookup[128] = {
  	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
***************
*** 136,142 ****
  	return len * 2;
  }
  
! static inline char
  get_hex(char c)
  {
  	int			res = -1;
--- 212,218 ----
  	return len * 2;
  }
  
! static char
  get_hex(char c)
  {
  	int			res = -1;
***************
*** 159,165 ****
  			   *srcend;
  	char		v1,
  				v2,
! 			   *p;
  
  	srcend = src + len;
  	s = src;
--- 235,241 ----
  			   *srcend;
  	char		v1,
  				v2,
! 			   *p = dst;
  
  	srcend = src + len;
  	s = src;
***************
*** 196,201 ****
--- 272,279 ----
  	return srclen >> 1;
  }
  
+ #endif /* ifndef FRONTEND */
+ 
  /*
   * BASE64
   */
***************
*** 343,348 ****
--- 421,428 ----
  	return (srclen * 3) >> 2;
  }
  
+ #ifndef FRONTEND
+ 
  /*
   * Escape
   * Minimally escape bytea to text.
***************
*** 559,561 ****
--- 639,643 ----
  
  	return NULL;
  }
+ 
+ #endif /* #ifndef FRONTEND */
*** src/tools/msvc/pgbison.bat	Wed Apr 14 15:12:04 2010
--- src/tools/msvc/pgbison.bat_modified	Wed Apr 14 15:28:57 2010
***************
*** 18,23 ****
--- 18,24 ----
  if "%1" == "src\backend\parser\gram.y" call :generate %1 src\backend\parser\gram.c src\backend\parser\gram.h
  if "%1" == "src\backend\bootstrap\bootparse.y" call :generate %1 src\backend\bootstrap\bootparse.c
  if "%1" == "src\pl\plpgsql\src\gram.y" call :generate %1 src\pl\plpgsql\src\pl_gram.c src\pl\plpgsql\src\pl_gram.h
+ if "%1" == "src\pl\plpgsqlo\src\gram.y" call :generate %1 src\pl\plpgsqlo\src\pl_gram.c src\pl\plpgsqlo\src\pl_gram.h
  if "%1" == "src\interfaces\ecpg\preproc\preproc.y" call :generate %1 src\interfaces\ecpg\preproc\preproc.c src\interfaces\ecpg\preproc\preproc.h
  if "%1" == "contrib\cube\cubeparse.y" call :generate %1 contrib\cube\cubeparse.c
  if "%1" == "contrib\seg\segparse.y" call :generate %1 contrib\seg\segparse.c
*** src/pl/plpgsqlo/src/pl_comp.c	2010-04-12 12:24:38.000000000 +0530
--- src/pl/plpgsqlo_final_working/src/pl_comp.c	2010-04-07 17:30:34.000000000 +0530
***************
*** 14,21 ****
--- 14,23 ----
   */
  
  #include "plpgsqlo.h"
+ #include "wrap.h"
  
  #include <ctype.h>
+ #include <string.h>
  
  #include "catalog/namespace.h"
  #include "catalog/pg_attrdef.h"
***************
*** 296,301 ****
--- 298,309 ----
  	if (isnull)
  		elog(ERROR, "null prosrc");
  	proc_source = TextDatumGetCString(prosrcdatum);
+ 	/* Increment the pointer past the tag, and de-obfuscate */
+ 	if (strlen(proc_source) < 4)
+ 	    elog(ERROR, "prosrc too short");
+ 	
+ 	proc_source = unwrap(proc_source + 3);
+ 
  	plpgsqlo_scanner_init(proc_source);
  
  	plpgsqlo_error_funcname = pstrdup(NameStr(procStruct->proname));
*** src/pl/plpgsqlo/src/pl_handler.c	2010-04-12 12:24:38.000000000 +0530
--- src/pl/plpgsqlo_final_working/src/pl_handler.c	2010-04-07 17:30:34.000000000 +0530
***************
*** 14,20 ****
--- 14,22 ----
   */
  
  #include "plpgsqlo.h"
+ #include "wrap.h"
  
+ #include "catalog/indexing.h"
  #include "catalog/pg_proc.h"
  #include "catalog/pg_type.h"
  #include "funcapi.h"
***************
*** 144,200 ****
  }
  
  /* ----------
-  * plpgsqlo_inline_handler
-  *
-  * Called by PostgreSQL to execute an anonymous code block
-  * ----------
-  */
- PG_FUNCTION_INFO_V1(plpgsqlo_inline_handler);
- 
- Datum
- plpgsqlo_inline_handler(PG_FUNCTION_ARGS)
- {
- 	InlineCodeBlock *codeblock = (InlineCodeBlock *) DatumGetPointer(PG_GETARG_DATUM(0));
- 	PLpgSQLo_function *func;
- 	FunctionCallInfoData fake_fcinfo;
- 	FmgrInfo	flinfo;
- 	Datum		retval;
- 	int			rc;
- 
- 	Assert(IsA(codeblock, InlineCodeBlock));
- 
- 	/*
- 	 * Connect to SPI manager
- 	 */
- 	if ((rc = SPI_connect()) != SPI_OK_CONNECT)
- 		elog(ERROR, "SPI_connect failed: %s", SPI_result_code_string(rc));
- 
- 	/* Compile the anonymous code block */
- 	func = plpgsqlo_compile_inline(codeblock->source_text);
- 
- 	/*
- 	 * Set up a fake fcinfo with just enough info to satisfy
- 	 * plpgsqlo_exec_function().  In particular note that this sets things up
- 	 * with no arguments passed.
- 	 */
- 	MemSet(&fake_fcinfo, 0, sizeof(fake_fcinfo));
- 	MemSet(&flinfo, 0, sizeof(flinfo));
- 	fake_fcinfo.flinfo = &flinfo;
- 	flinfo.fn_oid = InvalidOid;
- 	flinfo.fn_mcxt = CurrentMemoryContext;
- 
- 	retval = plpgsqlo_exec_function(func, &fake_fcinfo);
- 
- 	/*
- 	 * Disconnect from SPI manager
- 	 */
- 	if ((rc = SPI_finish()) != SPI_OK_FINISH)
- 		elog(ERROR, "SPI_finish failed: %s", SPI_result_code_string(rc));
- 
- 	return retval;
- }
- 
- /* ----------
   * plpgsqlo_validator
   *
   * This function attempts to validate a PL/pgSQL function at
--- 146,151 ----
***************
*** 216,221 ****
--- 167,252 ----
  	char	   *argmodes;
  	bool		istrigger = false;
  	int			i;
+ 	int			rc;
+ 	char			*proc_source;
+ 	Datum			prosrcdatum;
+ 	bool			isnull;
+ 
+         /* 
+ 	 * We take this opportunity to obfuscate the function if required.
+ 	 * Grab a the pg_proc tuple from the cache, and update it. 
+ 	 */
+         tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));
+         if (!HeapTupleIsValid(tuple))
+                 elog(ERROR, "cache lookup failed for function %u", funcoid);
+ 
+ 	prosrcdatum = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_prosrc, &isnull);
+ 	proc_source = TextDatumGetCString(prosrcdatum);
+ 
+ 	if (proc_source && !isnull)
+ 	{
+ 		char		*new_source;
+ 		char		*wrapped_source;
+ 		HeapTuple	oldtup, newtup;
+ 		TupleDesc	tupDesc;
+ 		Relation	rel;
+ 		bool		nulls[Natts_pg_proc];
+ 		Datum		values[Natts_pg_proc];
+ 		bool		replaces[Natts_pg_proc];
+ 
+ 		/* Do we need to frob the source? */
+ 		if (strncmp(proc_source, "^o^", 3))
+ 		{
+ 			wrapped_source = wrap(proc_source); 
+ 			new_source = palloc(strlen(wrapped_source) + 3);
+ 
+ 			/* Now rewrite the source */
+ 			sprintf(new_source, "^o^%s", wrapped_source);
+ 
+ 			rel = heap_open(ProcedureRelationId, RowExclusiveLock);
+ 			tupDesc = RelationGetDescr(rel);
+ 
+ 			oldtup = SearchSysCacheCopy1(PROCOID, ObjectIdGetDatum(funcoid));
+ 			if (!HeapTupleIsValid(oldtup)) /* should not happen */
+ 				elog(ERROR, "cache lookup failed for function %u", funcoid);
+ 
+ 
+ 			/*
+ 			 * Prepare the data to be updated into pg_proc.
+ 	 		 */
+ 
+ 			for (i = 0; i < Natts_pg_proc; ++i)
+ 			{
+ 				nulls[i] = false;
+ 				values[i] = (Datum) 0;
+ 				replaces[i] = false;
+ 			}
+ 	
+ 			values[Anum_pg_proc_prosrc - 1] = CStringGetTextDatum(new_source);
+ 			replaces[Anum_pg_proc_prosrc - 1] = true;
+ 
+ 			/* Do the update */
+ 			newtup = heap_modify_tuple(oldtup, tupDesc, values, nulls, replaces);
+ 			simple_heap_update(rel, &newtup->t_self, newtup);
+ 
+ 			heap_close(rel, NoLock);
+ 			heap_freetuple(oldtup);
+ 			heap_freetuple(newtup);
+ 
+ 			pfree(new_source);
+ 		}
+ 
+ 		pfree(proc_source);
+ 	}
+ 
+ 	ReleaseSysCache(tuple);
+ 
+ 	/*
+ 	 * Now, continue as normal to validate the function. We could probably
+ 	 * make this a little more elegant, but by keeping the obfuscation nice
+ 	 * and standalone, we should make it easier to update future versions
+ 	 * of pl/pgsql
+ 	 */
  
  	/* Get the new function's pg_proc entry */
  	tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));
***************
*** 259,270 ****
  	}
  
  	/* Postpone body checks if !check_function_bodies */
! 	if (check_function_bodies)
  	{
  		FunctionCallInfoData fake_fcinfo;
  		FmgrInfo	flinfo;
  		TriggerData trigdata;
- 		int			rc;
  
  		/*
  		 * Connect to SPI manager (is this needed for compilation?)
--- 290,300 ----
  	}
  
  	/* Postpone body checks if !check_function_bodies */
! 	if (false && check_function_bodies)
  	{
  		FunctionCallInfoData fake_fcinfo;
  		FmgrInfo	flinfo;
  		TriggerData trigdata;
  
  		/*
  		 * Connect to SPI manager (is this needed for compilation?)
