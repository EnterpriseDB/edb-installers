diff -c -r plpgsqlo-postgresql-9.2beta2/src/pl/plpgsqlo/src/Makefile plpg/src/pl/plpgsqlo/src/Makefile
*** plpgsqlo-postgresql-9.2beta2/src/pl/plpgsqlo/src/Makefile	Wed Jul  4 13:08:07 2012
--- plpg/src/pl/plpgsqlo/src/Makefile	Wed Jul  4 13:11:54 2012
***************
*** 13,26 ****
  # Shared library parameters
  NAME= plpgsqlo
  
! override CPPFLAGS := -I. -I$(srcdir) $(CPPFLAGS)
! SHLIB_LINK = $(filter -lintl, $(LIBS))
  rpath =
  
! OBJS = pl_gram.o pl_handler.o pl_comp.o pl_exec.o pl_funcs.o pl_scanner.o
  
  DATA = plpgsqlo.control plpgsqlo--1.0.sql plpgsqlo--unpackaged--1.0.sql
  
  all: all-lib
  
  # Shared library stuff
--- 13,41 ----
  # Shared library parameters
  NAME= plpgsqlo
  
! # XXX: We should make sure that "wrap.c" is compiled with all
! # optimizations and without -g, to make reverse engineering a bit harder.
! #override CPPFLAGS := -I. -I$(srcdir) $(CPPFLAGS)
! override CPPFLAGS := -I. -I$(pgcrypto_dir) -I$(srcdir) $(CPPFLAGS)
! SHLIB_LINK = $(filter -lintl, $(LIBS)) -lz
  rpath =
  
! # This location might depend on the installation directories. Therefore
! # we can't subsitute it into pg_config.h.
! ifdef krb_srvtab
! override CPPFLAGS += -DPG_KRB_SRVTAB='"$(krb_srvtab)"'
! endif
! 
! include $(top_srcdir)/src/backend/common.mk
! 
! LINKED_SOURCES= wrap.c md5.c encode.c
! 
! OBJS = pl_gram.o pl_handler.o pl_comp.o pl_exec.o pl_funcs.o pl_scanner.o encode.o wrap.o md5.o
  
  DATA = plpgsqlo.control plpgsqlo--1.0.sql plpgsqlo--unpackaged--1.0.sql
  
+ PLPGSQLO_OBJS = wrap.o md5.o encode.o
+ 
  all: all-lib
  
  # Shared library stuff
diff -c -r plpgsqlo-postgresql-9.2beta2/src/pl/plpgsqlo/src/encode.c plpg/src/pl/plpgsqlo/src/encode.c
*** plpgsqlo-postgresql-9.2beta2/src/pl/plpgsqlo/src/encode.c	Wed Jul  4 13:09:52 2012
--- plpg/src/pl/plpgsqlo/src/encode.c	Wed Jul  4 14:51:09 2012
***************
*** 12,22 ****
   *-------------------------------------------------------------------------
   */
  #include "postgres.h"
! 
  #include <ctype.h>
  
  #include "utils/builtins.h"
  
  
  struct pg_encoding
  {
--- 12,44 ----
   *-------------------------------------------------------------------------
   */
  #include "postgres.h"
! #include "wrap.h"
  #include <ctype.h>
  
  #include "utils/builtins.h"
  
+ #ifdef FRONTEND
+ 
+ #include "postgres_fe.h"
+ #undef ereport
+ #define ereport(x,y) (fprintf(stderr, "edbwrap error: could not wrap\n"), exit(1))
+ #undef elog
+ #define elog(x,y) (fprintf(stderr, "edbwrap error: could not wrap\n"), exit(1))
+ 
+ /* No assert checks in frontend ... */
+ #undef Assert
+ #define Assert(condition)
+ 
+ /* Frontend-specific memory handling  */
+ #undef palloc
+ #define palloc fe_palloc
+ #undef pfree
+ #define pfree free
+ 
+ extern void * fe_palloc(int size);
+ 
+ #endif /* ifdef FRONTEND */
+ 
  
  struct pg_encoding
  {
***************
*** 25,32 ****
  	unsigned	(*encode) (const char *data, unsigned dlen, char *res);
  	unsigned	(*decode) (const char *data, unsigned dlen, char *res);
  };
  
! static const struct pg_encoding *pg_find_encoding(const char *name);
  
  /*
   * SQL functions.
--- 47,109 ----
  	unsigned	(*encode) (const char *data, unsigned dlen, char *res);
  	unsigned	(*decode) (const char *data, unsigned dlen, char *res);
  };
+ #ifndef FRONTEND
+ 	static const struct pg_encoding *pg_find_encoding(const char *name);
+ #endif
+ 
+ static unsigned b64_encode(const char *src, unsigned len, char *dst);
+ static unsigned b64_enc_len(const char *src, unsigned srclen);
+ static unsigned b64_decode(const char *src, unsigned len, char *dst);
+ static unsigned b64_dec_len(const char *src, unsigned srclen);
+ 
+ /*
+  * Base64 encode 'data', of length 'datalen'. Returns a palloc'd,
+  * null-terminated string.
+  */
+ char *
+ encode_base64(char *data, int datalen)
+ {
+       char *result;
+       int   res;
+       int   estlen;
+ 
+       estlen     = b64_enc_len(data, datalen);
+       result     = palloc(estlen + 1);
+       res        = b64_encode(data, datalen, result);
+       
+       /* Make this FATAL 'cause we've trodden on memory ... */
+       if (res > estlen)
+               elog(FATAL, "overflow - encode estimate too small");
  
!       result[res] = '\0';
! 
!       return result;
! }
! 
! /*
!  * Decodes a base64 encoded, null-terminated string 'data'. The returned
!  * piece of memory is palloc'd, and its length is stored in *resultlen.
!  */
! char *
! decode_base64(char *data, int *resultlen)
! {
!       char *result;
!       int   estlen;
!       int   datalen = strlen(data);
! 
!       estlen     = b64_dec_len(data, datalen);
!       result     = palloc(estlen);
!       *resultlen = b64_decode(data, datalen, result);
!       
!       /* Make this FATAL 'cause we've trodden on memory ... */
!       if (*resultlen > estlen)
!               elog(FATAL, "overflow - encode estimate too small");
! 
!       return result;
! }
! 
! 
! #ifndef FRONTEND
  
  /*
   * SQL functions.
***************
*** 109,115 ****
   * HEX
   */
  
! static const char hextbl[] = "0123456789abcdef";
  
  static const int8 hexlookup[128] = {
  	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
--- 186,192 ----
   * HEX
   */
  
! static const char *hextbl = "0123456789abcdef";
  
  static const int8 hexlookup[128] = {
  	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
***************
*** 136,142 ****
  	return len * 2;
  }
  
! static inline char
  get_hex(char c)
  {
  	int			res = -1;
--- 213,219 ----
  	return len * 2;
  }
  
! static char
  get_hex(char c)
  {
  	int			res = -1;
***************
*** 159,165 ****
  			   *srcend;
  	char		v1,
  				v2,
! 			   *p;
  
  	srcend = src + len;
  	s = src;
--- 236,242 ----
  			   *srcend;
  	char		v1,
  				v2,
! 			   *p = dst;
  
  	srcend = src + len;
  	s = src;
***************
*** 196,201 ****
--- 273,280 ----
  	return srclen >> 1;
  }
  
+ #endif /* ifndef FRONTEND */
+ 
  /*
   * BASE64
   */
***************
*** 343,348 ****
--- 422,429 ----
  	return (srclen * 3) >> 2;
  }
  
+ #ifndef FRONTEND
+ 
  /*
   * Escape
   * Minimally escape bytea to text.
***************
*** 559,561 ****
--- 640,644 ----
  
  	return NULL;
  }
+ 
+ #endif /* #ifndef FRONTEND */
diff -c -r plpgsqlo-postgresql-9.2beta2/src/pl/plpgsqlo/src/pl_comp.c plpg/src/pl/plpgsqlo/src/pl_comp.c
*** plpgsqlo-postgresql-9.2beta2/src/pl/plpgsqlo/src/pl_comp.c	Wed Jul  4 13:08:27 2012
--- plpg/src/pl/plpgsqlo/src/pl_comp.c	Wed Jul  4 12:47:17 2012
***************
*** 14,21 ****
--- 14,23 ----
   */
  
  #include "plpgsqlo.h"
+ #include "wrap.h"
  
  #include <ctype.h>
+ #include <string.h>
  
  #include "catalog/namespace.h"
  #include "catalog/pg_proc.h"
***************
*** 295,300 ****
--- 297,308 ----
  	if (isnull)
  		elog(ERROR, "null prosrc");
  	proc_source = TextDatumGetCString(prosrcdatum);
+ 	/* Increment the pointer past the tag, and de-obfuscate */
+ 	if (strlen(proc_source) < 4)
+         	elog(ERROR, "prosrc too short");
+        
+ 	proc_source = unwrap(proc_source + 3);
+ 
  	plpgsqlo_scanner_init(proc_source);
  
  	plpgsqlo_error_funcname = pstrdup(NameStr(procStruct->proname));
diff -c -r plpgsqlo-postgresql-9.2beta2/src/pl/plpgsqlo/src/pl_handler.c plpg/src/pl/plpgsqlo/src/pl_handler.c
*** plpgsqlo-postgresql-9.2beta2/src/pl/plpgsqlo/src/pl_handler.c	Wed Jul  4 13:08:27 2012
--- plpg/src/pl/plpgsqlo/src/pl_handler.c	Wed Jul  4 14:51:57 2012
***************
*** 14,26 ****
--- 14,29 ----
   */
  
  #include "plpgsqlo.h"
+ #include "wrap.h"
  
+ #include "catalog/indexing.h"
  #include "catalog/pg_proc.h"
  #include "catalog/pg_type.h"
  #include "funcapi.h"
  #include "miscadmin.h"
  #include "utils/builtins.h"
  #include "utils/guc.h"
+ #include "utils/rel.h"
  #include "utils/lsyscache.h"
  #include "utils/syscache.h"
  
***************
*** 144,210 ****
  }
  
  /* ----------
-  * plpgsqlo_inline_handler
-  *
-  * Called by PostgreSQL to execute an anonymous code block
-  * ----------
-  */
- PG_FUNCTION_INFO_V1(plpgsqlo_inline_handler);
- 
- Datum
- plpgsqlo_inline_handler(PG_FUNCTION_ARGS)
- {
- 	InlineCodeBlock *codeblock = (InlineCodeBlock *) DatumGetPointer(PG_GETARG_DATUM(0));
- 	PLpgSQLo_function *func;
- 	FunctionCallInfoData fake_fcinfo;
- 	FmgrInfo	flinfo;
- 	Datum		retval;
- 	int			rc;
- 
- 	Assert(IsA(codeblock, InlineCodeBlock));
- 
- 	/*
- 	 * Connect to SPI manager
- 	 */
- 	if ((rc = SPI_connect()) != SPI_OK_CONNECT)
- 		elog(ERROR, "SPI_connect failed: %s", SPI_result_code_string(rc));
- 
- 	/* Compile the anonymous code block */
- 	func = plpgsqlo_compile_inline(codeblock->source_text);
- 
- 	/* Mark the function as busy, just pro forma */
- 	func->use_count++;
- 
- 	/*
- 	 * Set up a fake fcinfo with just enough info to satisfy
- 	 * plpgsqlo_exec_function().  In particular note that this sets things up
- 	 * with no arguments passed.
- 	 */
- 	MemSet(&fake_fcinfo, 0, sizeof(fake_fcinfo));
- 	MemSet(&flinfo, 0, sizeof(flinfo));
- 	fake_fcinfo.flinfo = &flinfo;
- 	flinfo.fn_oid = InvalidOid;
- 	flinfo.fn_mcxt = CurrentMemoryContext;
- 
- 	retval = plpgsqlo_exec_function(func, &fake_fcinfo);
- 
- 	/* Function should now have no remaining use-counts ... */
- 	func->use_count--;
- 	Assert(func->use_count == 0);
- 
- 	/* ... so we can free subsidiary storage */
- 	plpgsqlo_free_function_memory(func);
- 
- 	/*
- 	 * Disconnect from SPI manager
- 	 */
- 	if ((rc = SPI_finish()) != SPI_OK_FINISH)
- 		elog(ERROR, "SPI_finish failed: %s", SPI_result_code_string(rc));
- 
- 	return retval;
- }
- 
- /* ----------
   * plpgsqlo_validator
   *
   * This function attempts to validate a PL/pgSQL function at
--- 147,152 ----
***************
*** 226,231 ****
--- 168,253 ----
  	char	   *argmodes;
  	bool		istrigger = false;
  	int			i;
+         int                     rc;
+         char                    *proc_source;
+         Datum                   prosrcdatum;
+         bool                    isnull;
+   
+           /* 
+          * We take this opportunity to obfuscate the function if required.
+          * Grab a the pg_proc tuple from the cache, and update it. 
+          */
+           tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));
+           if (!HeapTupleIsValid(tuple))
+                   elog(ERROR, "cache lookup failed for function %u", funcoid);
+   
+         prosrcdatum = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_prosrc, &isnull);
+         proc_source = TextDatumGetCString(prosrcdatum);
+   
+         if (proc_source && !isnull)
+         {
+                 char            *new_source;
+                 char            *wrapped_source;
+                 HeapTuple       oldtup, newtup;
+                 TupleDesc       tupDesc;
+                 Relation        rel;
+                 bool            nulls[Natts_pg_proc];
+                 Datum           values[Natts_pg_proc];
+                 bool            replaces[Natts_pg_proc];
+   
+                 /* Do we need to frob the source? */
+                 if (strncmp(proc_source, "^o^", 3))
+                 {
+                         wrapped_source = wrap(proc_source); 
+                         new_source = palloc(strlen(wrapped_source) + 3);
+   
+                         /* Now rewrite the source */
+                         sprintf(new_source, "^o^%s", wrapped_source);
+   
+                         rel = heap_open(ProcedureRelationId, RowExclusiveLock);
+                         tupDesc = RelationGetDescr(rel);
+   
+                         oldtup = SearchSysCacheCopy1(PROCOID, ObjectIdGetDatum(funcoid));
+                         if (!HeapTupleIsValid(oldtup)) /* should not happen */
+                                 elog(ERROR, "cache lookup failed for function %u", funcoid);
+   
+   
+                         /*
+                          * Prepare the data to be updated into pg_proc.
+                          */
+   
+                         for (i = 0; i < Natts_pg_proc;  ++i)
+                         {
+                                 nulls[i] = false;
+                                 values[i] = (Datum) 0;
+                                 replaces[i] = false;
+                         }
+         
+                         values[Anum_pg_proc_prosrc - 1] = CStringGetTextDatum(new_source);
+                         replaces[Anum_pg_proc_prosrc - 1] = true;
+   
+                         /* Do the update */
+                         newtup = heap_modify_tuple(oldtup, tupDesc, values, nulls, replaces);
+                         simple_heap_update(rel, &newtup->t_self, newtup);
+   
+                         heap_close(rel, NoLock);
+                         heap_freetuple(oldtup);
+                         heap_freetuple(newtup);
+   
+                         pfree(new_source);
+                 }
+   
+                 pfree(proc_source);
+         }
+   
+         ReleaseSysCache(tuple);
+ 
+         /*
+          * Now, continue as normal to validate the function. We could probably
+          * make this a little more elegant, but by keeping the obfuscation nice
+          * and standalone, we should make it easier to update future versions
+          * of pl/pgsql
+          */
  
  	/* Get the new function's pg_proc entry */
  	tuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcoid));
***************
*** 269,280 ****
  	}
  
  	/* Postpone body checks if !check_function_bodies */
! 	if (check_function_bodies)
  	{
  		FunctionCallInfoData fake_fcinfo;
  		FmgrInfo	flinfo;
  		TriggerData trigdata;
- 		int			rc;
  
  		/*
  		 * Connect to SPI manager (is this needed for compilation?)
--- 291,301 ----
  	}
  
  	/* Postpone body checks if !check_function_bodies */
! 	if (false && check_function_bodies)
  	{
  		FunctionCallInfoData fake_fcinfo;
  		FmgrInfo	flinfo;
  		TriggerData trigdata;
  
  		/*
  		 * Connect to SPI manager (is this needed for compilation?)
diff -c -r plpgsqlo-postgresql-9.2beta2/src/tools/msvc/MSBuildProject.pm plpg/src/tools/msvc/MSBuildProject.pm
*** plpgsqlo-postgresql-9.2beta2/src/tools/msvc/MSBuildProject.pm	Fri Jun  1 04:46:55 2012
--- plpg/src/tools/msvc/MSBuildProject.pm	Wed Jul  4 13:20:00 2012
***************
*** 164,169 ****
--- 164,170 ----
              if ($grammarFile =~ /\.y$/)
              {
                  $outputFile =~ s{^src\\pl\\plpgsql\\src\\gram.c$}{src\\pl\\plpgsql\\src\\pl_gram.c};
+                 $outputFile =~ s{^src\\pl\\plpgsqlo\\src\\gram.c$}{src\\pl\\plpgsqlo\\src\\pl_gram.c};
                  print $f <<EOF;
      <CustomBuild Include="$grammarFile">
        <Message Condition="'\$(Configuration)|\$(Platform)'=='Debug|$self->{platform}'">Running bison on $grammarFile</Message>
diff -c -r plpgsqlo-postgresql-9.2beta2/src/tools/msvc/Mkvcbuild.pm plpg/src/tools/msvc/Mkvcbuild.pm
*** plpgsqlo-postgresql-9.2beta2/src/tools/msvc/Mkvcbuild.pm	Fri Jun  1 04:46:55 2012
--- plpg/src/tools/msvc/Mkvcbuild.pm	Wed Jul  4 12:56:55 2012
***************
*** 99,104 ****
--- 99,112 ----
      $plpgsql->AddFiles('src\pl\plpgsql\src', 'gram.y');
      $plpgsql->AddReference($postgres);
  
+     my $plpgsqlo =  $solution->AddProject('plpgsqlo','dll','PLs','src\pl\plpgsqlo\src');
+     $plpgsqlo->AddFiles('src\pl\plpgsqlo\src', 'gram.y');
+     $plpgsqlo->AddFiles('src\pl\plpgsqlo\src', 'encode.c');
+     $plpgsqlo->AddFiles('src\pl\plpgsqlo\src', 'wrap.c');
+     $plpgsqlo->AddFiles('src\pl\plpgsqlo\src', 'md5.c');
+     $plpgsqlo->AddReference($postgres);
+     $plpgsqlo->AddLibrary('ws2_32.lib');
+ 
      if ($solution->{options}->{perl})
      {
          my $plperlsrc = "src\\pl\\plperl\\";
diff -c -r plpgsqlo-postgresql-9.2beta2/src/tools/msvc/VCBuildProject.pm plpg/src/tools/msvc/VCBuildProject.pm
*** plpgsqlo-postgresql-9.2beta2/src/tools/msvc/VCBuildProject.pm	Fri Jun  1 04:46:55 2012
--- plpg/src/tools/msvc/VCBuildProject.pm	Wed Jul  4 12:58:47 2012
***************
*** 85,90 ****
--- 85,91 ----
              my $of = $fileNameWithPath;
              $of =~ s/\.y$/.c/;
              $of =~ s{^src\\pl\\plpgsql\\src\\gram.c$}{src\\pl\\plpgsql\\src\\pl_gram.c};
+ 	    $of =~ s{^src\\pl\\plpgsqlo\\src\\gram.c$}{src\\pl\\plpgsqlo\\src\\pl_gram.c};
              print $f '>'
                . $self->GenerateCustomTool('Running bison on ' . $fileNameWithPath,
                  "perl src\\tools\\msvc\\pgbison.pl $fileNameWithPath", $of)
